// generated by ChatGPT, with manually edited comments by CB,OP
// ============================================================================
//  Hybrid Optimized SA-IS Integer Array search for common subarray.
//  Cleaner, readable, and faster than simplified version
// ============================================================================

/**
 * SA-IS (Hybrid Optimized) for integer arrays
 * Linear-time, readable, and efficient
 */
function saisHybrid(array) {
    const n = array.length;
    if (n === 0) return [];
    if (n === 1) return [0];

    // Normalize array to 0..K alphabet
    const uniqueVals = Array.from(new Set(array));
    uniqueVals.sort((a, b) => a - b);
    const rankMap = new Map(uniqueVals.map((v, i) => [v, i]));
    const A = array.map(x => rankMap.get(x));
    const K = uniqueVals.length;

    // Mark types: 0=S, 1=L
    const ls = new Uint8Array(n);
    const isLMS = new Uint8Array(n);

    ls[n - 1] = 0; // last is S-type
    for (let i = n - 2; i >= 0; i--) {
        if (A[i] < A[i + 1]) ls[i] = 0;
        else if (A[i] > A[i + 1]) ls[i] = 1;
        else ls[i] = ls[i + 1];
        if (ls[i] === 1 && ls[i + 1] === 0) isLMS[i + 1] = 1;
    }

    // Bucket info
    const bkt = new Array(K).fill(0);
    for (const x of A) bkt[x]++;

    const bucketHeads = () => {
        const heads = new Array(K);
        let sum = 0;
        for (let i = 0; i < K; i++) {
            heads[i] = sum;
            sum += bkt[i];
        }
        return heads;
    };

    const bucketTails = () => {
        const tails = new Array(K);
        let sum = 0;
        for (let i = 0; i < K; i++) {
            sum += bkt[i];
            tails[i] = sum - 1;
        }
        return tails;
    };

    const SA = new Array(n).fill(-1);

    function induceLMS() {
        const tails = bucketTails();
        for (let i = 0; i < n; i++) {
            if (isLMS[i]) {
                const c = A[i];
                SA[tails[c]] = i;
                tails[c]--;
            }
        }
    }

    function induceL() {
        const heads = bucketHeads();
        for (let i = 0; i < n; i++) {
            const j = SA[i] - 1;
            if (j >= 0 && ls[j] === 1) {
                const c = A[j];
                SA[heads[c]] = j;
                heads[c]++;
            }
        }
    }

    function induceS() {
        const tails = bucketTails();
        for (let i = n - 1; i >= 0; i--) {
            const j = SA[i] - 1;
            if (j >= 0 && ls[j] === 0) {
                const c = A[j];
                SA[tails[c]] = j;
                tails[c]--;
            }
        }
    }

    function buildSA() {
        SA.fill(-1);
        induceLMS();
        induceL();
        induceS();

        // Extract LMS order
        const lms = [];
        for (let i = 0; i < n; i++) if (isLMS[i]) lms.push(i);

        // Name LMS substrings
        const names = new Array(n).fill(-1);
        let prev = -1;
        let nameID = 0;

        for (let idx of SA) {
            if (!isLMS[idx]) continue;

            let diff = false;
            if (prev === -1) diff = true;
            else {
                let i = prev, j = idx;
                while (true) {
                    if (A[i] !== A[j] || ls[i] !== ls[j]) {
                        diff = true;
                        break;
                    }
                    i++; j++;
                    if (isLMS[i] && isLMS[j]) break;
                    if (isLMS[i] !== isLMS[j]) { diff = true; break; }
                }
            }

            if (diff) nameID++;
            names[idx] = nameID - 1;
            prev = idx;
        }

        const lmsNames = lms.map(i => names[i]);

        let lmsSA;
        if (nameID === lmsNames.length) {
            // already unique
            lmsSA = new Array(lmsNames.length);
            for (let i = 0; i < lmsNames.length; i++) lmsSA[lmsNames[i]] = i;
        } else {
            lmsSA = saisHybrid(lmsNames);
        }

        // Re-induce SA from LMS order
        SA.fill(-1);
        const tails = bucketTails();
        for (let i = lmsSA.length - 1; i >= 0; i--) {
            const idx = lms[lmsSA[i]];
            const c = A[idx];
            SA[tails[c]] = idx;
            tails[c]--;
        }

        induceL();
        induceS();
        return SA;
    }

    return buildSA();
}

function doNothing(){
    //added for (in)sanity
}

// ---------------------------------------------------------------------------
//  Linear-time LCP (Kasai algorithm)
// ---------------------------------------------------------------------------
function buildLCP(array, sa) {
    const n = array.length;
    const rank = new Array(n);
    for (let i = 0; i < n; i++) rank[sa[i]] = i;

    const lcp = new Array(n - 1).fill(0);
    let h = 0;
    for (let i = 0; i < n; i++) {
        const r = rank[i];
        if (r === n - 1) { h = 0; continue; }
        const j = sa[r + 1];
        while (i + h < n && j + h < n && array[i + h] === array[j + h]) h++;
        lcp[r] = h;
        if (h > 0) h--;
    }
    return lcp;
}

// ============================================================================
//  IntegerSuffixArray (Hybrid Option C)
// ============================================================================
export class IntegerSuffixArrayHybrid {
    constructor(array) {
        this.array = array;
        this.suffixArray = saisHybrid(array);
        this.lcpArray = buildLCP(array, this.suffixArray);
    }

    static findCommonNonOverlapping(array1, array2, minLength = 2, separator = -1) {
        const n1 = array1.length;
        const INTERNAL_SEP = Number.MIN_SAFE_INTEGER;

        const combined = [...array1, INTERNAL_SEP, ...array2];
        const gsa = new IntegerSuffixArrayHybrid(combined);
        const SA = gsa.suffixArray;
        const LCP = gsa.lcpArray;

        const results = [];

        MAIN_LOOP:
        for (let i = 0; i < LCP.length; i++) {
            const len = LCP[i];
            if (len < minLength) continue;

            const s1 = SA[i];
            const s2 = SA[i + 1];

            const inA = s1 < n1;
            const inB = s2 < n1;
            if (inA === inB) continue;

            const startA = inA ? s1 : s2;
            const startB = inA ? s2 - (n1 + 1) : s1 - (n1 + 1);

            for (let k = 0; k < len; k++) {
                if (array1[startA + k] === separator || array2[startB + k] === separator) {
                    continue MAIN_LOOP;
                }
            }

            const sub = array1.slice(startA, startA + len);

            if (!results.some(r =>
                r.subarray.length === len &&
                r.subarray.every((x, j) => x === sub[j])
            )) {
                results.push({
                    subarray: sub,
                    array1Range: [startA, startA + len - 1],
                    array2Range: [startB, startB + len - 1]
                });
            }
        }

        // Remove overlapping: keep maximal
        results.sort((a, b) => b.subarray.length - a.subarray.length);
        const usedA = new Set();
        const usedB = new Set();
        const filtered = [];

        for (const r of results) {
            const [a1, a2] = r.array1Range;
            const [b1, b2] = r.array2Range;

            const overlapA = [...Array(a2 - a1 + 1).keys()].some(k => usedA.has(a1 + k));
            const overlapB = [...Array(b2 - b1 + 1).keys()].some(k => usedB.has(b1 + k));

            if (!overlapA && !overlapB) {
                filtered.push(r);
                for (let i = a1; i <= a2; i++) usedA.add(i);
                for (let i = b1; i <= b2; i++) usedB.add(i);
            }
        }

        return filtered;
    }
}

// ============================================================================
//  Multi-array common subarray discovery (Hybrid)
// ============================================================================
/** generated by ChatGPT! These JSDoc comments added manually.
 * 
 * @param {number[][]} arrays 
 * @param {number} minLength 
 * @param {number} separator 
 * @returns {{subarray:number[],arrays:{arrayIndex:number,ranges:number[][]}[]}[]}
 * 
 * ## Example:
 * -input:  [[1,2,3,4,5,6,7,8,9,10,11], [1,9,10,11,2,4,5,6,7,3]
 * -output: [{subarray:[4,5,6,7],arrays:[{arrayIndex:0,ranges:[[3,6]]},{arrayIndex:1,ranges:[[5,8]]}]},
 *           {subarray:[9,10,11],arrays:[{arrayIndex:0,ranges:[[8,10]]},{arrayIndex:1,ranges:[[1,3]]}]}]},
 */
export function findAllCommonSubarraysAmongHybrid(arrays, minLength = 2, separator = -1) {
    const N = arrays.length;
    const map = new Map();

    for (let i = 0; i < N; i++) {
        for (let j = i + 1; j < N; j++) {
            const pairRes = IntegerSuffixArrayHybrid.findCommonNonOverlapping(
                arrays[i], arrays[j], minLength, separator
            );

            for (const r of pairRes) {
                const key = JSON.stringify(r.subarray);

                if (!map.has(key)) {
                    map.set(key, { subarray: r.subarray, arrays: new Map() });
                }

                const entry = map.get(key);
                if (!entry.arrays.has(i)) entry.arrays.set(i, []);
                entry.arrays.get(i).push(r.array1Range);

                if (!entry.arrays.has(j)) entry.arrays.set(j, []);
                entry.arrays.get(j).push(r.array2Range);
            }
        }
    }

    const final = [];
    for (const data of map.values()) {
        const arrs = [];
        for (const [index, ranges] of data.arrays.entries()) {
            arrs.push({ arrayIndex: index, ranges });
        }
        arrs.sort((a, b) => a.arrayIndex - b.arrayIndex);
        final.push({ subarray: data.subarray, arrays: arrs });
    }

    return final;
}
